import{a as T,c as C,e as D,g as l,h as w,ia as A,k as I,l as _,n as M,q as S,t as h}from"./chunk-CJMLAJWE.js";var x=class b{constructor(e){this.http=e}docsData=h(null);categorizedData=h(null);loading=h(!1);error=h(null);loadedTypes=new Map;typeLoadingState=new D({});searchCache=new Map;PAGE_SIZE=50;SEARCH_RESULT_LIMIT=100;findTypeReferences(e){let t=/\b([A-Z][a-zA-Z0-9_]*(?:<[^>]+>)?)\b/g,s=[...e.matchAll(t)],n=new Set(s.map(r=>r[1]));return Array.from(n).map(r=>({typeName:this.cleanTypeName(r),exists:this.typeExists(this.cleanTypeName(r))}))}cleanTypeName(e){return e.split("<")[0]}typeExists(e){let t=this.categorizedData();return t?t.typeIndex.has(e):this.loadedTypes.size===0?/^[A-Z][a-zA-Z0-9_]*$/.test(e)&&e.length>2:this.getType(e)!==null}formatSignatureWithLinks(e){let t=e;return t=t.replace(/(public|private|protected|internal|static|override|virtual|abstract|readonly)/g,'<span class="keyword">$1</span>').replace(/(\w+)\s+(\w+)\s*\(/g,'<span class="return-type">$1</span> <span class="method-name">$2</span>(').replace(/(\w+)\s*:\s*(\w+)/g,'<span class="param-name">$1</span>: <span class="param-type">$2</span>'),t}getReferencedTypes(e){return this.findTypeReferences(e).filter(({typeName:s,exists:n})=>n&&s.length>2&&!["bool","void","string","int","object","float","double","long","short","byte","char"].includes(s.toLowerCase()))}loadDocs(){return this.docsData()?l(this.docsData()):(this.loading.set(!0),this.error.set(null),this.http.get("assets/docs_index.gz",{responseType:"arraybuffer"}).pipe(_(async e=>{try{if(!("DecompressionStream"in window))throw new Error("Compression Streams API not supported in this browser");let s=new ReadableStream({start(a){a.enqueue(new Uint8Array(e)),a.close()}}).pipeThrough(new DecompressionStream("gzip")).getReader(),n=[];for(;;){let{done:a,value:p}=await s.read();if(a)break;n.push(p)}let r=n.reduce((a,p)=>a+p.length,0),i=new Uint8Array(r),o=0;for(let a of n)i.set(a,o),o+=a.length;let m=new TextDecoder().decode(i),y=JSON.parse(m);return this.docsData.set(y),this.loading.set(!1),this.storeFullDataForLazyLoading(y),y}catch(t){throw this.error.set("Failed to decompress documentation data"),this.loading.set(!1),console.error("Decompression error:",t),t}}),I(1)))}storeFullDataForLazyLoading(e){this.loadedTypes.set("<global>",e.types),this.categorizedData.set(this.categorizeData(e))}categorizeData(e){let t={metadata:{generated_at:e.generated_at,total_types:e.total_types,total_members:e.total_members,type_counts:T({},e.type_counts)},categories:{classes:new Map,enums:new Map,interfaces:new Map,structs:new Map},typeIndex:new Map,memberIndex:new Map,inheritance:new Map,references:new Map,overrides:new Map};for(let s of e.types){switch(s.kind){case"class":t.categories.classes.set(s.name,s);break;case"enum":t.categories.enums.set(s.name,s);break;case"interface":t.categories.interfaces.set(s.name,s);break;case"struct":t.categories.structs.set(s.name,s);break}t.typeIndex.set(s.name,s),t.memberIndex.set(s.name,s.members),s.base_types&&s.base_types.length>0&&t.inheritance.set(s.name,s.base_types),this.buildCrossReferences(s,t.references)}return this.buildOverrideRelationships(t),t}buildCrossReferences(e,t){for(let s of e.members){let n=this.findTypeReferences(s.signature);for(let{typeName:r}of n)t.has(r)||t.set(r,new Set),t.get(r).add(e.name)}}buildOverrideRelationships(e){for(let t of e.typeIndex.values())if(!(!t.base_types||t.base_types.length===0)){for(let s of t.members)if(s.modifiers.includes("override")){let n=`${t.name}.${s.name}`,r=this.findOverriddenMethod(t,s,e);r&&e.overrides.set(n,{overrides:r,overriddenBy:[]})}}for(let[t,s]of e.overrides.entries())if(s.overrides){let n=s.overrides,r=e.overrides.get(n);r||(r={overriddenBy:[]},e.overrides.set(n,r)),r.overriddenBy.push(t)}}findOverriddenMethod(e,t,s){for(let n of e.base_types){let r=s.typeIndex.get(n);if(!r)continue;let i=r.members.find(o=>o.name===t.name&&(o.kind===t.kind||o.kind==="method"&&t.kind==="method"));if(i)return`${r.name}.${i.name}`;if(r.base_types&&r.base_types.length>0){let o=this.findOverriddenMethod(r,t,s);if(o)return o}}}getDocsData(){return this.docsData}getCategorizedData(){return this.categorizedData}getLoading(){return this.loading}getError(){return this.error}getTypesByCategory(e){let t=this.categorizedData();if(!t)return[];let s=t.categories[e==="class"?"classes":e==="enum"?"enums":e==="interface"?"interfaces":"structs"];return Array.from(s.values())}getTypesByCategoryPaginated(e,t=0){let s=this.getTypesByCategory(e),n=t*this.PAGE_SIZE,r=n+this.PAGE_SIZE;return l(s.slice(n,r))}getCategoryCount(e){let t=this.categorizedData();return t?t.metadata.type_counts[e]:0}getCategoryPageCount(e){let t=this.getCategoryCount(e);return Math.ceil(t/this.PAGE_SIZE)}getTypeReferences(e){let t=this.categorizedData();if(!t)return[];let s=t.references.get(e);return s?Array.from(s):[]}getAllCategories(){let e=this.categorizedData();return e?[{category:"class",count:e.metadata.type_counts.class,types:Array.from(e.categories.classes.values())},{category:"enum",count:e.metadata.type_counts.enum,types:Array.from(e.categories.enums.values())},{category:"interface",count:e.metadata.type_counts.interface,types:Array.from(e.categories.interfaces.values())},{category:"struct",count:e.metadata.type_counts.struct,types:Array.from(e.categories.structs.values())}]:[]}getCategoryDisplayName(e){switch(e){case"class":return"Classes";case"enum":return"Enums";case"interface":return"Interfaces";case"struct":return"Structs";default:return"Types"}}getCategoryRoute(e){return`/docs/category/${e}`}getInheritance(e){let t=this.categorizedData();if(!t)return[];let s=t.inheritance.get(e);return s||[]}getOverrideInfo(e,t){let s=this.categorizedData();if(!s)return null;let n=`${e}.${t}`;return s.overrides.get(n)||null}parseMemberKey(e){let t=e.lastIndexOf(".");return{typeName:e.substring(0,t),memberName:e.substring(t+1)}}getMemberFromKey(e){let t=this.parseMemberKey(e),s=this.categorizedData();if(!s||!t.typeName)return null;let n=s.memberIndex.get(t.typeName);return n&&n.find(r=>r.name===t.memberName)||null}getNamespaces(){let e=this.docsData();return e?[{name:"<global>",type_count:e.total_types,types:[]}]:[]}getNamespaceTypes(e,t=0){let s=this.loadedTypes.get(e)||[],n=t*this.PAGE_SIZE,r=n+this.PAGE_SIZE;return l(s.slice(n,r))}getNamespaceTypeCount(e){return(this.loadedTypes.get(e)||[]).length}getNamespacePageCount(e){let t=this.getNamespaceTypeCount(e);return Math.ceil(t/this.PAGE_SIZE)}getNamespace(e){let t=this.docsData();return t&&e==="<global>"?{name:"<global>",type_count:t.total_types,types:[]}:null}getType(e){let t=this.categorizedData();if(t){let s=t.typeIndex.get(e);if(s)return{type:s,namespace:"<global>",category:s.kind}}for(let[s,n]of this.loadedTypes.entries()){let r=n.find(i=>i.name===e);if(r)return{type:r,namespace:s,category:r.kind}}return null}getTypeAsync(e){let t=this.getType(e);return t?l(t):this.loadedTypes.size===0?this.loadDocs().pipe(w(()=>this.getType(e))):l(null)}search(e){if(!e.trim())return l([]);let t=e.toLowerCase();return this.searchCache.has(t)?(console.log("Search results from cache for:",e),l(this.searchCache.get(t))):(console.log("Starting search for:",e),new C(s=>{let n=[],r=e.toLowerCase(),i=0,o=()=>{let m=Array.from(this.loadedTypes.entries()),y=1;if(i>=m.length){let a=n.sort((p,v)=>v.relevance-p.relevance).slice(0,this.SEARCH_RESULT_LIMIT);this.searchCache.set(t,a),console.log(`Search completed: found ${a.length} results (limited from ${n.length})`),s.next(a),s.complete();return}for(let a=0;a<y&&i<m.length;a++){let[p,v]=m[i];for(let c of v){let d=0,g="name";if(c.name.toLowerCase().includes(r)&&(d+=10,c.name.toLowerCase().startsWith(r)&&(d+=5)),c.file.toLowerCase().includes(r)&&(d+=3,g="file"),c.access_modifier&&c.access_modifier.toLowerCase().includes(r)&&(d+=3),c.modifiers)for(let f of c.modifiers)f.toLowerCase().includes(r)&&(d+=3);let z=10;for(let f=0;f<Math.min(c.members.length,z);f++){let u=c.members[f];u.signature.toLowerCase().includes(r)&&(d+=2,g="signature"),u.name&&u.name.toLowerCase().includes(r)&&(d+=3,g="signature"),u.return_type&&u.return_type.toLowerCase().includes(r)&&(d+=2,g="signature"),u.access_modifier&&u.access_modifier.toLowerCase().includes(r)&&(d+=2,g="signature")}d>0&&n.push({type:c,namespace:p,category:c.kind,matchType:g,relevance:d})}i++}setTimeout(o,0)};o()}))}static \u0275fac=function(t){return new(t||b)(S(A))};static \u0275prov=M({token:b,factory:b.\u0275fac,providedIn:"root"})};export{x as a};
